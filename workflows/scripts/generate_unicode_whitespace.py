import os
import sys
from typing import List

sys.path.append(os.path.abspath(f"{os.path.dirname(__file__)}/.."))

import lib.config as config
from lib.log import lcheck_passed, lprint

proplist_path = os.path.abspath(
    f"{os.path.dirname(os.path.abspath(__file__))}/../../sys.Text/data_unicode/ucd/PropList.txt"
)
output_path = os.path.abspath(
    f"{os.path.dirname(os.path.abspath(__file__))}/../../sys.Text/data/UnicodeWhitespace.h"
)


def to_cxx_u32_literal(hex_str: str) -> str:
    if len(hex_str) <= 4:
        return f"U'\\u{hex_str.zfill(4)}'"
    else:
        return f"U'\\U{hex_str.zfill(8)}'"


def main(argv: List[str]) -> None:
    config.check_name = "scripts:generate_unicode_whitespace"

    whitespace_ranges = []
    with open(proplist_path, "r", encoding="utf-8") as f:
        for line in f:
            # UUUU(..UUUU) ; <property> # <comment>
            if "; White_Space" in line:
                parts = line.split(";")
                if len(parts) < 1:
                    continue

                code_range = parts[0].strip()
                if ".." in code_range:
                    start, end = code_range.split("..")
                else:
                    start, end = code_range, code_range
                whitespace_ranges.append((start, end))

    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(f"/// @file {os.path.basename(output_path)}\n")
        f.write(
            "/// @brief Generated by `workflows/scripts/generate_unicode_whitespace.py`.\n"
        )
        f.write("/// @note If this file is out of date, please regenerate it!\n\n")
        f.write("#pragma once\n\n")
        f.write("namespace sys::internal\n")
        f.write("{\n")
        f.write(
            "    /// @brief Check if a character is a Unicode whitespace character.\n"
        )
        f.write("    constexpr bool dchar_is_ws(char32_t c) noexcept\n")
        f.write("    {\n")
        f.write("        return ")

        check_lines = []
        for start, end in whitespace_ranges:
            if start == end:
                check_lines.append(f"c == {to_cxx_u32_literal(start)}")
            else:
                check_lines.append(
                    f"(c >= {to_cxx_u32_literal(start)} && c <= {to_cxx_u32_literal(end)})"
                )

        f.write(" ||\n               ".join(check_lines))
        f.write(";\n")
        f.write("    }\n")
        f.write("}\n")

    lprint(f"Successfully generated `{output_path}`.")

    lcheck_passed()


if __name__ == "__main__":
    main(sys.argv)
